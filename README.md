# ProxySourceGenerator
[![Nuget](https://img.shields.io/nuget/v/ProxySourceGenerator?color=1182c2&logo=nuget)](https://www.nuget.org/packages/ProxySourceGenerator)

Generates proxy classes from classes and interfaces.

## Usage
- Add nuget package into your project [![Nuget](https://img.shields.io/nuget/v/ProxySourceGenerator?color=1182c2&logo=nuget)](https://www.nuget.org/packages/ProxySourceGenerator)
- Decorate a class or interface with `[GenerateProxy]` attribute:
### Autogenerating the proxy interface
> ```csharp
> [GenerateProxy]
> public class TestClass: ITestClass //ITestClass is autogenerated with non-private members
> {
>     public string AProperty { get; set; }
>     public int AMethodReturnsInt()
>     {
>         return Convert.ToInt32(AProperty);
>     }
>     public Task<string> AGenericMethodAsync<T>(T input)
>     {
>         return Task.FromResult(input.ToString());
>     }
> }
> ```
- This generates proxy class and corresponding `ITestClass` interface:
> ```csharp
> //Autogenerated
> public interface ITestClass
> {
>     public string AProperty { get; set; }
>     public int AMethodReturnsInt();
>     public Task<string> AGenericMethodAsync<T>(T input);
> }
> ```
- Create your proxy:
> ```csharp
> //First create an object
> var testObj = new TestClass();
> //Directly call constructor of the proxy
> var proxy = new TestClassProxy(testObj);
> //Or call the generic accessor
> var proxy = ProxyAccessor<ITestClass>.Create(testObj);
> ```
- Intercept methods or properties:
> ```csharp
> //Non Async method interception
> proxy.InterceptMethod = (string methodName,
>     InterceptMethodCallerHandler method,
>     Dictionary<string, object> parameters) =>
> {
>     Console.WriteLine("method called: " + methodName + string.Join(",",parameters.Select(kv => (kv.Key, kv.Value).ToString())));
>     return method(parameters);
> };
> //Async method interception
> proxy.InterceptAsyncMethod = async (string methodName,
>     InterceptAsyncMethodCallerHandler methodAsync,
>     Dictionary<string, object> parameters) =>
> {
>     Console.WriteLine("async method called: " + methodName + string.Join(",",parameters.Select(kv => (kv.Key, kv.Value).ToString())));
>     return await methodAsync(parameters);
> };
> 
> proxy.InterceptPropertySetter = (propertyName, setter, value) =>
> {
>     Console.WriteLine($"property set: {propertyName} with value '{value}'");
>     setter(value);
> };
> 
> proxy.InterceptPropertyGetter = (propertyName, getter) =>
> {
>     Console.WriteLine($"property get: {propertyName}");
>     return getter();
> };
> ```
- You can access methods/properties with explicit casting or `Access` property:
> ```csharp
> var intVal = proxy.Access.APropertyAsInt();
> //or 
> var testObjProxied = (ITestClass)proxy; //this also proxied.
> ```
- You can access the underlying object too:
> ```csharp
> var testObjUnderlying = proxy.UnderlyingObject; //this is not proxied, returns original object.
> ```

### Using the existing interface
If the interface already exists and does not want to be generated automatically, you can decorate the interface with `[GenerateProxy]` to proxy all calls to the interface.
```csharp
[GenerateProxy]
public interface ITestClass
{
    public string AProperty { get; set; }
    public T AGenericMethod<T>();
}
```

### Genereate from base class
You can generate interfaces and its proxy classes from all classes that derive from a base class:
```csharp
[GenerateProxy(GenerateForDerived=true)]
public abstract ABaseClass //abstract is optional
{
    public void BaseMethod(){}
}

public class SuperClass: ABaseClass
{
}
```
This code generates an interface named `ISuperClass` and a proxy named `SuperClassProxy` which contains `BaseMethod` from `ABaseClass`.

### Generate without interface
Normally the proxy pattern implementation in c# uses interfaces to intercept methods and properties. But there is another aproach uses overriding virtual members of the underlying class.
To use this aproach, you can set `UseInterface` argument to `false`.
```csharp
[GenerateProxy(UseInterface=false)]
public class AClass
{
    public virtual int AProperty { get; }
    public virtual string AMethod(int parameter){}
    
    public void NotProxiedMethod(){}// not proxied because it isn't virtual.
}
```
This code generates a proxy class derived from `AClass`, and it overrides all virtual members to intercept calls. It skips non-virtual members of the class. Also this method doesn't generates an interface form `AClass`.
You can combine both `UseInterface=false` with `GenerateForDerived=true` for generating all subclasses without interface method.

### Change accessibility of proxy class
The generated proxy classes and interfaces are internal and partial types, so you can change accessibility by defining another partial class:
```csharp
public partial class TestClassProxy
{
}

public partial interface ITestClass {}
```

### Notes
- Can't generate proxy from `sealed` classes with `UseInterface=false`.
```csharp
[GenerateProxy(UseInterface=false)]
public sealed class ASealedClass //NonSense, can't be derived from this clas because of sealed.
{
}
```
- Can't generate proxy members/accessors from `private` members/accessors.
```csharp
[GenerateProxy]
public class AClass
{
    private string PrivateProp { get;set; } //not generated
    public int PublicProp { get; private set; } //generates only for the getter.
}
```